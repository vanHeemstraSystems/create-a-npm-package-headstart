[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Create an NPM Package",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "building-our-application/index.html",
    "href": "building-our-application/index.html",
    "title": "Building Our Application",
    "section": "",
    "text": "Creating a ReactJS Component\nCreating a GitHub Repository\nCreating a GitHub Action\nInstalling Commitizen\nSetting Up Semantic Release\nPublishing a ReactJS Component as a Package to Node Package Manager (NPM) Registry"
  },
  {
    "objectID": "building-our-application/setting-up-semantic-release/index.html",
    "href": "building-our-application/setting-up-semantic-release/index.html",
    "title": "Setting Up Semantic Release",
    "section": "",
    "text": "Based on “Fully Automated npm publish using GitHub Actions and Semantic Release” at https://www.youtube.com/watch?v=QZdY4XYbqLI\nThe next step is to setup semantic release.\nFirst, install the following two packages:\n$ npm install  semantic-release semantic-release-cli --save-dev\nAdd the following to package.json:\n...\n  scripts: {\n    ...\n    \"semantic-release\": \"semantic-release --branches main\"\n    ...\n  }  \n...\npackage.json\nMore … TO DO: format below transcript to readible text and instructions to follow\nand add over here into our package.json i’m sorry over here into our package.json another command called commit and that commit we’ll just do git cc so commit and i will just do git cz right there right and now i can go back to my terminal and it didn’t finish yet so right now i will fast forward this for you right now when it finished you can still do your pit. like you were doing before but now instead of doing git commit we will do npm run commit and when you do this npm run commit now git cz will run let me just run this again git cz will run and you will get these very very nice message helpers for you so let’s say that we added a new feature whatever feature that was and let’s say that feature you are creating a blog and it’s on the user settings that you change something so you will do user settings you will click enter and now over here you can put a message so we add a new picture to the user for example i will click enter then i don’t want a longer message you can say that if you have breaking changes or not because this will impact the way that semantic release will create the version of your package in my case i will sa no which is the default i will say that it doesn’t affect any open issues but if it does you you can say the issue number and then when it creates the release for you it will put a nice link between your release and the issues that you fixed now that that thing happened i can do a git push and you will see that all of those files are now over there on github action on github we can go over here to our github actions right now so i will just go to my code and i will open our workflows folder the publish yaml file and i will click on the edit button and over here you will see why i love to use this bit because if you come over here you have all the helpers that you might want to have so i will call this next job i will call it the publish job itself so i will do publish i will click now enter and over here if i do control space you can see that i have autocomplete for everything i might want to have i will say that it will run for example on ubuntu latest and i will also say at in this specific job i will need the previous job to be finalized in this case the quality job so if i unit test files into our quality job over here i don’t want my publish job to run right in a second i will also add an if over there in order to only run these if we are in master okay so in case we are in in a pull request like i’m saying here let’s say we are in a pull request to master this will run in the branch so i don’t want to publish from that branch i really want to publish when the commit is on master not when there is a pull request to master so we will add that if in a few seconds but before we add that if now we are in a very good stage to say the steps and so let’s just do the steps and in those steps i will say the same thing that we said before i will use the checkout and i will set the environment for node.js so let me just come over here do a control v and at this stage the last bit we want to do is npmci just to install our packages and as you can see on the right side of the screen you can have a cache over there so if you feel that doing npmci in two different stages of your process is making stuff a little bit slower you can use this action over there called cache and it will keep your node modules into cache if you want to right now the next step after we do the npmci will be to run let me just remove these spices will be to run semantic release right and now as we have this we will run semantic release semantic release will understand the commits that we have and decide the next version to run before we just commit this bit let’s just go over here and as you can see in this context i will leave all of these urls into the video description if you want to investigate it a bit more yourself right but we can have this if that i had already highlighted and once again we will have autocomplete for this but what’s happening over here is just myself checking if the reference where we are on is the mind branch and if it is i want to run my action so i can come over here after the runs on i will put that if and as i was saying to you if i do github dot as you can see i have all of the autocompletes that you might want to have and that’s the main reason i run all my actions code inside this little editor okay now that we have all of them and i think we have everything to publish the first version of our package so let’s do a commit let’s just say something over here added publish job for example right i will commit that one and now if i go to the actions we will see if it will run or not it might run it might fail we will see and then we will fix it we can already see that our action failed so we can go inside and see what it felt and you can click on the job click once again and we can see that it failed so let’s just read the error can only install packages when your package.json and package log or are in sync please update your log file with an npm installed so let’s just do that let’s just do an npm first a git pool then an npm install this once again will take a few minutes to run now we can commit this again and we will see that our actions will then run so i will just do an asd in a fix i will just say asd isd in the commit i really don’t care that much about the commit message at this stage right i just want to push it to then see our action to run so if i come over here and i now click on actions and other actions started we can click over here and hopefully this time all our actions will run and when they run we will have a version on npm to be honest even before it finished i am already 100 sure it will fail because we didn’t put our npm underscore token as the environment variable so while this thing will run and i’m 100 sure it will file we can go already into here open our github actions in our vs code and the only thing i’m going to do over here at the bottom will be to have an environment and that environment we will just do the following oops one two i will say npm token column and then i will just say the secrets secrets dot npm underscore oops underscore token npm token so let’s put this one secrets dot npm uh gita git up token we can even copy paste to avoid any typo i will save this one we can now come on to our command line do our run acp we can even say that it was a fix package json and now add add git up token just to have a better message for once and now this one will commit and now we can go over here to our actions click in actions click on this one and wait for it to run once again and as you can see now we have a successful job we can even now go to our code and if you click over here you can see that we have releases over there i will click on the releases and now you can see all the stuff that we did for those releases you can see that we have a proper change log of what happened in our release so if we have a branch let’s say called development or something like that and you are putting a lot of features there and a lot of bug fixes every time that you then merge it into the main branch you will have a very nice change lock in your releases which is very very nice"
  },
  {
    "objectID": "building-our-application/creating-a-github-action/index.html",
    "href": "building-our-application/creating-a-github-action/index.html",
    "title": "Creating a GitHub Action",
    "section": "",
    "text": "Based on “Fully Automated npm publish using GitHub Actions and Semantic Release” at https://www.youtube.com/watch?v=QZdY4XYbqLI\nThe next step is to create a GitHub action so click the “Actions” tab on the GitHub repository page of foo-component. From the Continuous Integration workflows choose the workflow called NodeJS: Build and test a Node.js project with npm. and click on “configure”.\nRename the default name that is given to the Yaml file, here: node.js.yml, to something more appropriate: publish.yml.\nNext, lets look inside of the newly created Action:\n# This workflow will do a clean installation of node dependencies, cache/restore them, build the source code and run tests across different versions of node\n# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs\n\nname: Node.js CI\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\njobs:\n...\n.github/workflows/publish.yml\nThen on push to the branch main all of the underneath jobs will run at the same time. Equally, if there is a pull request from any branch into main that request will run all of those jobs as well.\nNext is jobs.\n...\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x, 16.x, 18.x]\n        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n        cache: 'npm'\n    - run: npm ci\n    - run: npm run build --if-present\n    - run: npm test\n...\n.github/workflows/publish.yml\nThe build currently runs only on ubuntu the latest version. To run this in multiple operating systems, change the above as shown here (including renaming ‘build’ to ‘quality’ as this job is all about checking quality):\n...\njobs:\n  quality:\n\n    runs-on: ${{ matrix.os}}\n\n    strategy:\n      matrix:\n        node-version: [14.x, 16.x, 18.x]\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        # See supported Node.js release schedule at https://nodejs.org/en/about/releases/\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n        cache: 'npm'\n    - run: npm ci\n    - run: npm run build --if-present\n    - run: npm test\n...\n.github/workflows/publish.yml\nThis matrix now has three operating systems and three versions of node, so we will have (three times three is) nine jobs running.\nWARNING: If you find errors when building these combinations of os and node version, you can adjust this node.js.yml file so that it takes fewer os and/or node versions into account. For example, leave out node version 14. This way your builds may succeed at the cost of platform / backwards compatibility.\nFollowing are steps:\n...\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n        cache: 'npm'\n    - run: npm ci\n    - run: npm run build --if-present\n    - run: npm test\n...\n.github/workflows/publish.yml\nThe first step is just to clone and check out our branch:\n...\n    - uses: actions/checkout@v3\n...\n.github/workflows/publish.yml\nThe second step is to set up node.js and as you can see it’s already using that matrix for the node version that we are using:\n...\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n        cache: 'npm'\n...\n.github/workflows/publish.yml\nThen the run commands:\n...\n    - run: npm ci\n    - run: npm run build --if-present\n    - run: npm test\n...\n.github/workflows/publish.yml\nThe first run command is the npm ci, which is similar to npm install.\nThe second run command is building this library we are running tests.\nThe third run command will run any tests defined.\nCommit the new GitHub Action file (here: node.js.yml).\nBy commiting to the main branch, this will start already the new GitHub Action."
  },
  {
    "objectID": "building-our-application/creating-a-reactjs-component/index.html",
    "href": "building-our-application/creating-a-reactjs-component/index.html",
    "title": "Creating a ReactJS Component",
    "section": "",
    "text": "Based on “Create and Publish packages to npm - React Component Library using tsdx” at https://www.youtube.com/watch?v=aVFasPXkyRE\nIn your terminal create a new ReactJS Component (here: foo-component):\n$ npx tsdx create foo-component\nIf the following error occurs:\nCannot read property 'pickAlgorithm' of null\nSimply run:\n$ npm cache clear --force\nIf you get prompted as follows:\nNeed to install the following packages:\n  tsdx@0.14.1\nOk to proceed? (y)\nAgree by choosing: y for yes\nNext, when being given the choice below:\n? Choose a template ... \n  basic\n  react\n> react-with-storybook  \nWe choose react-with-storybook this time, so we can develop our ReactJS application making use of Storybook. Hence, move the sideways caret (>) in front of react-with-storybook and confirm your choice by hitting the Enter key.\n√ Choose a template · react-with-storybook\n? Who is the package author? »  \nAs the package owner state the unique fully-qualified domain-name (here: vanheemstrasystems.com) to which the new to be created component belongs.\n√ Who is the package author? · vanheemstrasystems.com\n√ Created foo-component\n√ Installed dependencies\n\n  Awesome! You're now ready to start coding.\n\n  I already ran yarn install for you, so your next steps are:\n    cd foo-component\n\n  To start developing (rebuilds on changes):\n    yarn start\n\n  To build for production:\n    yarn build\n\n  To test your library with Jest:\n    yarn test\n\n  Questions? Feedback? Please let me know!\n  https://github.com/formium/tsdx/issues\nNow we have created the skeleton of the new ReactJS component, called foo-component!\nEnter the newly created directory foo-component like:\n$ cd foo-component\nOpen Visual Studio Code from within this directory:\n$ code .\nThe first change we are going to make is in package.json. Change the name of the package from an unscoped name (here: foo-component) to a scoped package (here: @vanheemstrasystems/foo-component). This is to guarantee the name of this component won’t be colliding with a component that has been created by some other creator on the npm registry.\n...\n\"name\": \"@vanheemstrasystems/foo-component\"\n...\npackage.json\nNext, we have to run the npm install command once, to create a package-lock.json file, which our workflow action later on will be expecting to exist.\n$ npm install\nNow move to the next section “Creating a GitHub Repository”, see you there!"
  },
  {
    "objectID": "building-our-application/installing-commitizen/index.html",
    "href": "building-our-application/installing-commitizen/index.html",
    "title": "Installing Commitizen",
    "section": "",
    "text": "Based on “Create and Publish packages to npm - React Component Library using tsdx” at https://www.youtube.com/watch?v=aVFasPXkyRE\nInstall commitizen as follows in the same directory as where package.json is kept:\n$ npm install commitizen --save-dev --save-exact\nThe above will add a development dependency in your package.json, like:\n...\n  \"devDependencies\": {\n    ...\n    \"commitizen\": \"4.2.5\",\n    ...\n  }\n...\npackage.json\nCreate a new file called “.czrc” at the same directory as where package.json is kept, with the following content:\n{\n  \"path\": \"cz-conventional-changelog\"\n}\n.czrc\nThis just tells Commitizen which adapter we actually want our contributors to use when they try to commit to this repo.\nFor husky users, which we are, add the following configuration to the project’s package.json file:\n\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"tsdx lint\",\n    \"prepare-commit-msg\": \"exec < /dev/tty && npx cz --hook || true\"\n  }\n}\nWhy exec < /dev/tty? By default, git hooks are not interactive. This command allows the user to use their terminal to interact with Commitizen during the hook.\nOptionally: Add the following script entry to package.json:\n...\n \"scripts\": {\n   ...\n   \"commit\": \"git-cz\",\n   ...\n }\n...\npackage.json\nYou can now run the following command after having made a change to your code that needs to be committed:\n$ npm run commit\nAlso try if you run locally the following command:\n$ git commit\nYou will get an interactive prompt where you can select the type of change that you’re committing:\nfix: A bug fix\ndocs: Documentation only changes\nstyle: Changes that do not affect the meaning of the code (white-space, formatting, missing se..)\nrefactor: A code change that neither fixes a bug nor adds a feature\nperf: A code change that improves performance\ntest: Adding missing tests or correcting existing tests\nbuild: Changes that affect the build system or external dependencies (example scopes: gulp, br..)\n(Move up and down to reveal more choices)\nAdd the “Commitizen friendly” badge to the top of your README.md file using the following markdown:\n[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)\nLet’s go to the next section: “Setting Up Semantic Release”."
  },
  {
    "objectID": "building-our-application/creating-a-github-repository/index.html",
    "href": "building-our-application/creating-a-github-repository/index.html",
    "title": "Creating a GitHub Repository",
    "section": "",
    "text": "Based on “Fully Automated npm publish using GitHub Actions and Semantic Release” at https://www.youtube.com/watch?v=QZdY4XYbqLI\nPreviously we have created a new ReactJS component called foo-component.\nThe .github directory was also created.\nNow we’ll make sure we have a repository on GitHub (for convenience, but not mandatorily, named the same: foo-component).\nWe do not have to created a README.md or LICENSE file as these have already been created when creating the ReactJS component.\nNow inside the new directory in Visual Studio Code, remove the .github directory with all content.\n$ rm -R .github\nNext, run this command:\n$ git init\nThe above command will initialize a new .github directory for you.\nIf you are prompted that the initial branch is called master, we decide to rename it now to a more politically correct name as main:\n$ git branch -m main\nContinue by adding all files and directories to git by typing:\n$ git add .\nAnd finally, run:\n$ git commit -m \"first commit\"\n$ git branch -M main\n$ git remote add origin git@github.com:vanHeemstraSystems/foo-component.git\n$ git push -u origin main\nUpon inspection, you should now see all files and directories that were created as part of the ReactJS component to be in the GitHub repository at https://github.com/vanHeemstraSystems/foo-component"
  },
  {
    "objectID": "building-our-application/publishing-a-reactjs-component/index.html",
    "href": "building-our-application/publishing-a-reactjs-component/index.html",
    "title": "Publishing a ReactJS Component",
    "section": "",
    "text": "Based on “Fully Automated npm publish using GitHub Actions and Semantic Release” at https://www.youtube.com/watch?v=QZdY4XYbqLI\nMore …"
  },
  {
    "objectID": "requirements/index.html",
    "href": "requirements/index.html",
    "title": "Requirements",
    "section": "",
    "text": "Requirements of the application of this site"
  },
  {
    "objectID": "SUMMARY.html",
    "href": "SUMMARY.html",
    "title": "Create an NPM Package",
    "section": "",
    "text": "Table of contents\n\nCreate an NPM Package"
  },
  {
    "objectID": "introduction/index.html",
    "href": "introduction/index.html",
    "title": "Introduction",
    "section": "",
    "text": "Fully automated release!!! semantic-release automates the whole package release workflow including: determining the next version number, generating the release notes and publishing the package.\nThis removes the immediate connection between human emotions and version numbers, strictly following the Semantic Versioning specification.\nsemantic-release is meant to be executed on the CI environment after every successful build on the release branch. This way no human is directly involved in the release process and the releases are guaranteed to be unromantic and unsentimental.\nGitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub.\nHere we’ll show how we can publish our packages automatically to npm every time someone does a git commit into our main branch. For that we are going to use github actions and semantic release. If you have never heard about semantic release, it will look into all the commit messages we did since the last time we publish to npm, try to understand from all those messages what is the next version that we should publish and then go ahead and do the publish for us so that process becomes completely automated by having github actions and semantic release."
  },
  {
    "objectID": "conclusion/index.html",
    "href": "conclusion/index.html",
    "title": "Conclusion",
    "section": "",
    "text": "Conclusion of this site"
  }
]